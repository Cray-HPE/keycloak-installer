
imagesHost: dtr.dev.cray.com

# A list of sealedSecrets passed in to be deployed.
sealedSecrets: []

setup:
  image:
    repository: dtr.dev.cray.com/cray/cray-keycloak-setup
    # tag: latest
    pullPolicy: Always
  keycloak:
    service: keycloak
    clusterGw:
      dnsName: api-gw-service-nmn.local
      route: /keycloak
    adminClient:
      id: admin-client
      secret:
        name: admin-client-auth
        namespaces:
          - services
          - default
          - ims
    systemComputeClient:
      id: system-compute-client
      secret:
        name: system-compute-client-auth
        namespaces:
          - services
          - default
          - ims
    systemPXEClient:
      id: system-pxe-client
      secret:
        name: system-pxe-client-auth
        namespaces:
          - services
          - default
          - ims
    systemNexusClient:
      id: system-nexus-client
      secret:
        name: system-nexus-client-auth
        namespaces:
          - services
          - default
          - nexus
    wlmClient:
      id: wlm-client
      secret:
        name: wlm-client-auth
        namespaces:
          - services
          - default
          - user
    gatekeeper:
      client:
        id: gatekeeper
        secret:
          name: keycloak-gatekeeper-client
          namespaces:
            - services
      proxiedHosts:
        - shs_prometheus.local
        - shs_alertmanager.local
        - shs_grafana.local
        - istio_prometheus.local
        - istio_grafana.local
        - istio_kiali.local
        - istio_jaeger.local
        - kube_monitoring_prometheus.local
        - kube_monitoring_alertmanager.local
        - kube_monitoring_grafana.local
        - ceph_monitoring_prometheus.local
        - vcs_hostname.local
        - sma-grafana.local
        - sma-kibana.local
    customerAccessUrl: "https://auth.local/keycloak"
    masterAdminSecretName: keycloak-master-admin-auth

keycloak:
  # Custom value for init container image source
  imagesHost: dtr.dev.cray.com
  kubectlImageVersion: "0.2.0"

  keycloak:
    replicas: 3
    podAnnotations:
      # port 7600 is used for jgroups (Java clustering) traffic
      # it's UDP and non-HTTP so need to prevent istio from wrapping.
      traffic.sidecar.istio.io/excludeInboundPorts: '7600'
      traffic.sidecar.istio.io/excludeOutboundPorts: '7600'
    image:
      tag: 9.0.0
    # NOTE: When upgrading this should be able to be removed. -XX:+UseContainerSupport is the default in chart version 7.3.0
    extraEnv: |
      - name: JAVA_OPTS
        value: -XX:+UseContainerSupport -XX:MaxRAMPercentage=50.0 -Djava.net.preferIPv4Stack=true -Djboss.modules.system.pkgs=org.jboss.byteman -Djava.awt.headless=true
      - name: PROXY_ADDRESS_FORWARDING
        value: "true"
    basepath: keycloak
    username: admin
    existingSecret: keycloak-master-admin-auth
    serviceAccount:
      name: jobs-watcher
    # When nodeAffinity isn't needed anymore, note that the podAntiAffinity is
    # copied from the defaults so `affinity` can be removed.
    priorityClassName: csm-high-priority-service
    affinity: |
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchLabels:
                {{- include "keycloak.selectorLabels" . | nindent 10 }}
              matchExpressions:
                - key: role
                  operator: NotIn
                  values:
                    - test
            topologyKey: kubernetes.io/hostname
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: no_external_access
              operator: NotIn
              values:
              - "True"
    # cray-postgres-operator provides the secret, etc.
    persistence:
      dbVendor: postgres
      dbName: service_db
      dbHost: keycloak-postgres
      existingSecret: service-account.keycloak-postgres.credentials
      existingSecretPasswordKey: password
      existingSecretUsernameKey: username
    # This is copied from cray-services
    extraInitContainers: |
      - name: keycloak-wait-for-postgres
        image: {{ .Values.imagesHost }}/loftsman/docker-kubectl:{{ .Values.kubectlImageVersion }}
        command:
        - /bin/sh
        - -c
        - |
          while true; do
            JOB_CONDITION="$(kubectl get jobs -n services -l app.kubernetes.io/name=keycloak-wait-for-postgres -o jsonpath='{.items[0].status.conditions[0].type}')"
            JOB_CONDITION_RC=$?
            if [ $JOB_CONDITION_RC -eq 0 ]; then
              if [ "$JOB_CONDITION" == 'Complete' ]; then
                echo "Completed"
                break
              fi
              echo "Waiting for the keycloak-wait-for-postgres job in the services namespace to complete, current condition is $(kubectl get jobs -n services -l app.kubernetes.io/name=keycloak-wait-for-postgres -o jsonpath='{.items[0].status}')"
              sleep 3
            elif [ $JOB_CONDITION_RC -ne 1 ]; then
              echo "'kubectl get jobs' failed with exit code $JOB_CONDITION_RC , failing"
              exit 1
            else
              echo "'kubectl get jobs' failed with exit code $JOB_CONDITION_RC , will retry"
              sleep 3
            fi
          done
        resources:
          limits:
            cpu: 500m
            memory: 100Mi
          requests:
            cpu: 30m
            memory: 20Mi
    # We've seen keycloak terminated with the default 5sec timeout, so increase to 30sec
    livenessProbe: |
      httpGet:
        path: {{ if ne .Values.keycloak.basepath "" }}/{{ .Values.keycloak.basepath }}{{ end }}/
        port: http
      initialDelaySeconds: 300
      timeoutSeconds: 30
    readinessProbe: |
      httpGet:
        path: {{ if ne .Values.keycloak.basepath "" }}/{{ .Values.keycloak.basepath }}{{ end }}/realms/master
        port: http
      initialDelaySeconds: 30
      timeoutSeconds: 30
    resources:
      requests:
        memory: "1500Mi"
        cpu: "1000m"
      limits:
        memory: "5000Mi"
        cpu: "4000m"
    cli:
      # Configures Keycloak to read a CA cert from /certs/cert.jks, would contain the custom LDAP server certificate.
      custom: |
        /subsystem=keycloak-server/spi=truststore:add()
        /subsystem=keycloak-server/spi=truststore/provider=file:add(enabled=true)
        /subsystem=keycloak-server/spi=truststore/provider=file:write-attribute(name=properties.file,value=/certs/certs.jks)
        /subsystem=keycloak-server/spi=truststore/provider=file:write-attribute(name=properties.password,value=password)
        /subsystem=keycloak-server/spi=truststore/provider=file:write-attribute(name=properties.hostname-verification-policy,value=WILDCARD)
        /subsystem=keycloak-server/spi=truststore/provider=file:write-attribute(name=properties.disabled,value=false)
    # Contains the CA cert, it's created outside of this chart and may be updated by localization.
    extraVolumes: |
      - name: certs-volume
        secret:
          secretName: keycloak-certs
      - name: rsa-plugin-plugin-volume
        configMap:
          name: cray-keycloak-rsa-plugin
    extraVolumeMounts: |
      - mountPath: /certs
        name: certs-volume
        readOnly: true
      - name: rsa-plugin-plugin-volume
        mountPath: /mnt/rsa-plugin
        readOnly: true
    startupScripts:
      rsa_plugin_cli: "cp /mnt/rsa-plugin/RSA-CLI-Provider.jar /opt/jboss/keycloak/standalone/deployments/"
      rsa_plugin_plugin: "cp /mnt/rsa-plugin/RSA-Plugin-Provider.jar /opt/jboss/keycloak/standalone/deployments/"
      rsa_plugin_theme: "cp /mnt/rsa-plugin/RSAAuthenticator.ftl /opt/jboss/keycloak/themes/base/login/"

postgresDbBackup:
  enabled: true
  image:
    repository: "dtr.dev.cray.com/cray/cray-postgres-db-backup"
    pullPolicy: IfNotPresent
    tag: "0.1.0"

  storageBucket: postgres-backup
  storageSecret: postgres-backup-s3-credentials

  schedule: "10 2 * * *"  # Once per day at 2:10AM

  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: ""

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  resources:
    limits:
      cpu: 1000m
      memory: 500Mi
    requests:
      cpu: 100m
      memory: 200Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}
